---
title: "Network Analysis in R - Part 2"
date: "2019-08-24"
categories: ["R", "network"]
execute:
  echo: true
  warning: false
  message: false
  code-overflow: wrap
image: "https://www.yworks.com/assets/images/landing-pages/demo-clustering-biconnected-components.c7bcb893be.png"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In last post, I covered the basic components of IGRAPH objects and how to manipulate IGRAPH. You may notice that most of those manipulation do not really require a IGRAPH object to play with. However, in this post, you will realize the advantage of using IGRAPH over data.frame in network analysis.

In this session, we are going to use a new un-directed graph called `gr` generated by `sample_gnp()`.

```{r warning=FALSE, message=FALSE}
library(igraph)
library(tidyverse)
library(ggraph)
library(gridExtra)
```

```{r gr}
# generate random graph 
set.seed(12) 
gr <- sample_gnp(10, 0.3)
plot(gr)

```

# Graph measurement

## Degree and strength

**Degree** measures the number of edges connected to given vertex. In `igraph`, we use `degree`. Be aware that, for directed graph, the node degree can be **"in-degree"** (the edge number pointing to the node) and **"out-degree"** (the edge number pointing from node). We can also summaries the all degree by using `degree_distribution`.

```{r degree}
# get degree for each node 
degree(gr, v=1:10)

# degree distribution
degree_distribution(gr) # probability for degree 0,1,2,3,4
```

`strength` is weighted version of `degree`, by summing up the edge weights of the adjacent edges for each vertex.

```{r strength}
# add random weight attribute
set.seed(12)
gr2 <- gr %>% set_edge_attr(
  "weight",index=E(gr),
  value=sample(seq(0,1,0.05),size=length(E(gr)))
)
# calculate strength
strength(gr2, weights = E(gr)$weight)
```

## Order/distance and path

Order measures the edge number from one node to the other. In `igraph` package, we use `distances` function to get order between two vertices. For directed graph, `in` mode only follow the paths toward the first node, while `out` mode goes away from the first node. If no connection can be made, `Inf` will be return.

```{r order}
# count all edges from 1 to 10, regardless of direction 
distances(gr, v=1, to=10, mode="all", weights = NA)

# pairwise distance table 
distances(gr, mode="all")
```

To get detail route from one node to the other, we use `path`.

```{r path}
# shortest path to connect
all_shortest_paths(gr, 1,10)$res


# all path to connect
all_simple_paths(gr, 1,10)

```

## Transitivity

**Transitivity** measures the probability that the adjacent vertices of a vertex are connected. This is also called the **clustering coefficient**, a proxy to determine how well connected the graph is. This property is very important in social networks, and to a lesser degree in other networks.

```{r Transitivity}
# two extreme classes -- full graph and ring graph
g1 = make_full_graph(10)
plot(g1)
transitivity(g1)

g2 = make_ring(10)
plot(g2)
transitivity(g2)

```

There are multiple different types of transitivity can be calculated (weighted or un-weighted). Also, the transitivity can be calculated locally for a sub-graph by specifying vertex ids. See details by `?transitivity`

## Centrality

**Centrality** indices identify the most important vertices within a graph. In other words, the "hub" of network. However, this "importance" can be conceived in two ways:

-   relation to a type of flow or transfer across the network.
-   involvement in the cohesiveness of the network

The simplest of centrality indicator is degree centrality (`centr_degree`), aka, a node is important if it has most neighbors.

Besides degree centrality, there are

-   closeness centrality (`centr_clo`) - a node is important if it takes the shortest mean distance from a vertex to other vertices
-   between-ness centrality (`centr_betw`) - a node is important if extent to which a vertex lies on paths between other vertices are high.
-   eigenvector centrality (`centr_eigen`) - a node is important if it is linked to by other important nodes.

```{r centrality}
centr_degree(gr, mode="all")
centr_clo(gr, mode = "all")
centr_betw(gr, directed = FALSE)
centr_eigen(gr,directed = FALSE)
```

Many other centrality indicators refer to [wiki page of Centrality](https://en.wikipedia.org/wiki/Centrality).

# Graph clustering

Graph clustering is the most useful calculation that can be done in `igraph` object. There are a whole line of research on this. Only basic clustering methods were covered here.

## decompose graph

To split graph into connected sub-graph, `decompose.graph` calculates the connected components of your graph. A **component** is a sub-graph in which all nodes are inter-connected.

```{r decompose}
# decompose graph to connected components
dg <- decompose.graph(gr)
dg

# summary statics graph components
components(gr)

# plot components
coords <- layout_(gr, nicely())
plot(gr, layout=coords,
     mark.groups = split(as_ids(V(gr)), components(gr)$membership)
     )

```

## Cliques

**Clique** is a special sub-graph in which every two distinct vertices are adjacent. The direction is usually ignored for clique calculations

```{r clique}
# extract cliques that contain more than 3 vertices
cliques(gr, min=3)

# get cliques with largest number of vertices
largest_cliques(gr)

# plot cliques
cl <- cliques(gr, 3)

coords <- layout_(gr, nicely())
plot(gr, layout=coords,
     mark.groups=lapply(cl, function(g){as_ids(g)}), 
     mark.col=c("#C5E5E7","#ECD89A"))

```

## Communities and modules

Graph **communities structure** is defined if the nodes of the network can be easily grouped into (potentially overlapping) sets of nodes such that each set of nodes is densely connected internally. **Modularity** is always used as a measure the strength of division of a network into community for optimization methods in detecting community structure in networks.

There are many algorithms to cluster graph to communities.

-   `cluster_edge_betweenness` a hierarchical decomposition process where edges are removed in the decreasing order of their edge betweenness scores.\
-   `cluster_optimal` - a top-down hierarchical approach that optimizes the modularity function
-   `cluster_walktrap` - an approach based on random walks
-   `cluster_fast_greedy`
-   `cluster_label_prop`
-   `cluster_leading_eigen`
-   `cluster_Louvain`
-   `cluster_spinglass`

Which cluster method to use? Refer to this [stackoverflow post](https://stackoverflow.com/questions/9471906/what-are-the-differences-between-community-detection-algorithms-in-igraph) for more information.

```{r community}
# cluster graph using walktrap method, turn a ”communities” object
wtc <- cluster_walktrap(gr) 
wtc

# find membership for each vertex
membership(wtc)

# calculate modularity for walktrap clustering on this graph
modularity(wtc) 

# plot community
coords <- layout_(gr, nicely())
plot(wtc, gr, layout=coords)
```

To learn more about graph clustering:

1.  [NCSU course slide Introduction to Graph Cluster Analysis](https://www.csc2.ncsu.edu/faculty/nfsamato/practical-graph-mining-with-R/slides/pdf/Graph_Cluster_Analysis.pdf)

2.  [MIT open course Finding Clusters in Graphs](https://www.youtube.com/watch?v=cxTmmasBiC8)

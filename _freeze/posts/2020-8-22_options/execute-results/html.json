{
  "hash": "7c018f3629045aea6459a499d6acd7cd",
  "result": {
    "markdown": "---\ntitle: 'Taking options from command line'\ndate: \"2020-08-22\"\ncategories: [\"r\", \"bash\", \"perl\"]\nimage: \"https://www.source-data.com/wp-content/uploads/2019/11/options_0.jpg\"\n---\n\n\n\n\nTaking in options from command line is an essential step towards generalized usage of scripts. However, it is a chapter I skipped in almost all language textbooks since my primary goal was to code for a specific problem and did not mind re-writing the scripts in different situations.\n\nUsually the options following the scripts have two types\n\n-   direct inputs (with default definition within the script).\n-   the \"true\"\" options with \"-\" or \"--\" to allow optional manipulation\n\nFor the second type of options, it becomes a little bit complicated. First, this type options can be further grouped based whether there is argument value followed specified option (\"options with argument\" vs \"options without argument\"). In addition, it can also be classified by whether this option is mandatory or optional (although all mandatory options can be converted to optional by specifying the default value).\n\nIn this post, I will catch up on the options taken-in scripting in [Bash](#Bash), [R](#R) and [Perl](#Perl).\n\n### Bash {#Bash}\n\nBash script takes in first type of options using special variables based on the input orders `$1`, `$2`, ... For the unknown number of inputs, `$@` array is used to represents all arguments after script file (`$0`).\n\nFor the second type of options, there are two methods to take in options. One method is to use `while :; do; done` to read through all arguments (`$@`) after scripts by considering `--option` as an argument itself and `shift` it off in the loop. For each `--option`, we can use [`case; esac`](https://www.tutorialspoint.com/unix/case-esac-statement.htm) matching to specify what exact value should be.\n\nIn the following script, I listed the examples of \"mandatory non-empty option argument\", \"optional empty option argument\" and \"optional non-empty option argument\".\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#!/bin/bash\n\n## specifiy usage function\nusage()\n{\n        echo \"Usage: bash $0 [-h] -p p1 [-v] [-o output_file] bam1 bam2\" 1>&2\n}\n\n## setting defaults\nverbose=0 # default for optional empty option argument\n# p1=0 # all mandatory options can be converted to optional by specifying the default value\n\nwhile :; do\n    case $1 in\n        -p | --para ) # mandatory non-empty option argument (mandatory enforced later, or we can set default to make it optional)\n                if [[ \"$2\" && ! $2 =~ \"-\" ]]; then\n                        p1=$2\n                        shift\n                else\n                        echo 'ERROR: --para requires non-empty option argument'\n                        exit\n                fi\n        ;;\n        -v | --verbose ) # optional empty option argument (with default)\n                verbose=$((verbose + 1))\n        ;;\n        -o | --output ) # optional non-empty option argument\n                if [[ -f $2 ]]; then # prevent overwrite into a file exist in directory\n                        printf 'WARNING: --output argument %s is a file existing in directory\\n' \"$2\" >&2\n                        echo \"Are you sure about overwriting?\"\n                        echo \"Press any key to continue\"\n                        while [ true ] ; do\n                                read -n 1\n                                if [ $? = 0 ] ; then\n                                        break 1 # break the while [ true ] loop\n                                fi\n                        done\n                fi\n                output=$2\n                shift\n        ;;\n        -h | --help )           \n                usage\n                exit\n        ;;\n        -?*)\n                printf 'WARN: Unknown option (ignored): %s\\n' \"$1\" >&2\n                exit\n        ;;\n        *) # Default case: No more options, so break out of the loop.\n                break\n    esac\n    shift\ndone\n\n# mandatory argument\nif [[ -z $p1 ]]; then\n        echo 'ERROR: --para is mandatory argument'\n        exit\nfi\n\n# input after options are put into $@\nbams=$@\n\n# a simple function to execute \nprint_out()\n{\n        for bam in ${bams[@]}; do\n                echo \"$bam\"\n        done\n}\n\n# show what --para take in\necho \"$p1\"\n\n# execute function output\nif [[ ! -z $output ]]; then\n        print_out > $output\nelse\n        print_out\nfi\n```\n:::\n\n\nThe second method is to use `getopts` function with function-specific variables `$OPTARG` and `$OPTIND` to track the option value and option number. It can only take in the short format \"-\" options. The `:` following the `-o` will be passed to \\$OPTARG, thus, the different between \"options with argument\" and \"options without argument\" are shown in `o:` and `o` in `getopts` format.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nwhile getopts \":ho:\" opt; do\n        case ${opt} in\n                h )\n                        echo \"usage: bash $0 -o output_file folder1 folder2 ...\"\n                        exit\n                ;;\n                o )\n                        output=$OPTARG\n                ;;\n                \\? )\n                        echo \"Invalid option: $OPTARG\" 1>&2\n                        exit\n                ;;\n                : )\n                        echo \"Invalid option: $OPTARG requires an argument\" 1>&2\n                        exit\n                ;;\n        esac\ndone\nshift $((OPTIND -1))\ndirs=$@\n```\n:::\n\n\nPersonally, I would recommend the first method. The additional reading can be found http://mywiki.wooledge.org/BashFAQ/035\n\n### R {#R}\n\nMost R users execute the R script in Rstudio or R Console, and may never need to take in options. However, to execute R script in HPC environment, we submit `Rscript script.R` to the cluster for the jobs requiring high resources from command line.\n\nFor first type of options, `commandArgs` is all you need. It parses all arguments after script.R to the arguments vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs = commandArgs(trailingOnly=TRUE)\nfile1=args[1]\nfile2=args[2]\n```\n:::\n\n\nFor the second type of options, package `optparse` is useful. Function `make_option` is used to specify each option type (matching pattern, option type, default value, ...). To distinguish \"options with argument\" and \"options without argument\", we can specify `action` argument in `make_option` function.\n\n-   options with argument: `action=\"store\", type=\"character\"` (# this is default)\n-   options without argument: `action=\"store_true\"` (# by default, `type=\"logical\"`)\n\nAfter making option list, we use `parse_args(OptionParser(option_list))` to assign options to a list value (with long flag option as list element name).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(optparse)\n\noption_list = list(\n  # parameter 1 \n  make_option(\n    c(\"-p\",\"--para\"),\n    type=\"integer\", \n    default=1, \n    help=\"parameter 1 [default= %default]\"\n    ),\n  # optional output\n\tmake_option(\n\t  c(\"-o\", \"--out\"), \n\t  type=\"character\", \n\t  default=stdout(), \n    help=\"output file name [default= STDOUT]\", \n\t  metavar=\"character\"\n\t ),\n  # verbose\n  make_option(\n\t  c(\"-v\", \"--verbose\"), \n\t  action=\"store_true\",\n\t  default=F\n\t )\n)\n \nopts = parse_args(OptionParser(option_list=option_list))\nopts\n```\n:::\n\n\nThings need to be cautious\n\n-   final list, by default, have help function, thus no need to specify `-h`. To visualize the help page\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_args(OptionParser(option_list=option_list), args = c(\"--help\"))\n```\n:::\n\n\n-   long flag option is required.\n-   `default` argument in function `make_option` must not be NULL, otherwise, the option will not be included in the final list.\n-   There are other useful arguments including `dest`, `callback` and `metavar`. Learn more from\n\nBesides package `optparse`, `argparser` is another popular package. Please read [this blog](https://blog.sellorm.com/2017/12/30/command-line-utilities-in-r-pt-6/) for tutorial.\n\n### Perl {#Perl}\n\nPerl script takes every argument (after script) from command line into a special array `@ARGV`. We can easily read first type of options by parsing through `@ARGV`. This is very similar to `commandArgs` in R.\n\n\n::: {.cell}\n\n```{.perl .cell-code}\n#!/usr/bin/perl\nmy $usage=\"$0 file1 [file2 file3...]\nThis script is to print out first column of each file\nIt requires at least one input file \n\";\n\nif (scalar @ARGV < 1){\n  die $usage; # ensure there are arguments following the script\n}else{\n  for (my $i=0; $i < scalar @ARGV; $i++){ # go through each input file\n    open IN, \"<$ARGV[$i]\";\n    while (<IN>){\n      chomp;\n      my @items=split(/\\t/,$_);\n      print \"$items[0]\\n\";\n    }\n    close IN;\n  }\n}\n```\n:::\n\n\nIn above script, another special variable `$0` was used. It represents the script name itself (for example we can save above script as \"print_col1.pl\"). Thus, when the script is not followed by an input file, it will print usage\n\n> print_col1.pl file1 \\[file2 file3...\\]\\\n> This script is to print out first column of each file It requires at least one input file\n\nFor the second type of options, perl uses a module `Getopt` to parse options. The following script shows an example to print sequence length based on file format ([fasta vs fastq](https://compgenomr.github.io/book/fasta-and-fastq-formats.html)).\n\n\n::: {.cell}\n\n```{.perl .cell-code}\n#!/usr/bin/perl\nuse Getopt::Long;\n\nmy $usage=\"$0 [--format fasta] [--seqN] [--header] file [file2 file3 ...]\nthis script is to calculate sequence file from fastq/fasta file\n--format fasta|fastq # default is fasta\n--seqN integer # default is everything\n--header # default no header added\noutput directly to STDOUT as seq_name[tab]length\n\";\n\nmy $format=\"fasta\"; # set default as fasta format.\nmy $seqN=0; # set default for number of sequence to print (0 here means print all sequences)\nmy $header = 0;\t# option variable with default value (false)\nGetOptions(\n        \"format=s\" => \\$format, # the option here will read as string (s)\n        \"seqN=i\" => \\$seqN, # the option here will read as numeric (i)\n        \"header\"  => \\$header  # flag: if --header specified, it will become true\n);\n\nmy $n;\nif ($seqN!=0){\n  $n=0;\n}\nif (scalar @ARGV < 1){\n        die $usage;\n}else{\n        OUTER: for (my $i=0; $i < scalar @ARGV; $i++){\n                if ($header!=0){\n                  print \"seq_name\\tseq_len\\n\";\n                }\n                my $file=$ARGV[$i];\n                open IN, \"<$file\";\n                if ($format eq \"fasta\"){\n                        my $header;\n                        my $seq;\n                        while (<IN>){\n                                chomp;\n                                if(/^>/){\n                                        if($header){\n                                                my $len=length($seq);\n                                                print \"$header\\t$len\\n\";\n                                                $n++;\n                                                if ($seqN!=0 && $n==$seqN){\n                                                  last OUTER;\n                                                }\n                                        }\n                                        s/^>//;\n                                        my @header=split(/\\s+/, $_);\n                                        $header=$header[0];\n                                        $seq=\"\";\n                                }else{\n                                        $seq=$seq.$_;\n                                }\n                        }\n                        my $len=length($seq);\n                        print \"$header\\t$len\\n\";\n                }\n                elsif($format eq \"fastq\"){\n                        my $header;\n                        my $seq;\n                        my $line;\n                        while (<IN>){\n                                chomp;\n                                if ($line % 4==0){\n                                        if($header){\n                                                my $len=length($seq);\n                                                print \"$header\\t$len\\n\";\n                                                $n++;\n                                                if ($seqN!=0 && $n==$seqN){\n                                                  last OUTER;\n                                                }\n                                        }\n                                        s/^@//;\n                                        my @header=split(/\\s+/, $_);\n                                        $header=$header[0];\n                                        \n                                }elsif($line % 4==1){\n                                        $seq=$_;\n                                }\n                                $line++;\n                        }\n                        my $len=length($seq);\n                        print \"$header\\t$len\\n\";\n                }\n                close IN;\n        }\n}\n\n```\n:::\n\n\nFor more usage example of `Getopt`, please refer to its [perldoc](https://perldoc.perl.org/Getopt/Long.html) page.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
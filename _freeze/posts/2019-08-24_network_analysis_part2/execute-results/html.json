{
  "hash": "47f9239735f00485c5185e5004faff56",
  "result": {
    "markdown": "---\ntitle: \"Network Analysis in R - Part 2\"\ndate: \"2019-08-24\"\ncategories: [\"R\", \"network\"]\nexecute:\n  echo: true\n  warning: false\n  message: false\n  code-overflow: wrap\nimage: \"https://www.robcross.org/wp-content/uploads/2020/06/organizational-network-analysis.png\"\n---\n\n\n\n\nIn last post, I covered the basic components of IGRAPH objects and how to manipulate IGRAPH. You may notice that most of those manipulation do not really require a IGRAPH object to play with. However, in this post, you will realize the advantage of using IGRAPH over data.frame in network analysis.\n\nIn this session, we are going to use a new un-directed graph called `gr` generated by `sample_gnp()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(tidyverse)\nlibrary(ggraph)\nlibrary(gridExtra)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate random graph \nset.seed(12) \ngr <- sample_gnp(10, 0.3)\nplot(gr)\n```\n\n::: {.cell-output-display}\n![](2019-08-24_network_analysis_part2_files/figure-html/gr-1.png){width=672}\n:::\n:::\n\n\n# Graph measurement\n\n## Degree and strength\n\n**Degree** measures the number of edges connected to given vertex. In `igraph`, we use `degree`. Be aware that, for directed graph, the node degree can be **\"in-degree\"** (the edge number pointing to the node) and **\"out-degree\"** (the edge number pointing from node). We can also summaries the all degree by using `degree_distribution`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get degree for each node \ndegree(gr, v=1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 4 1 3 2 1 4 3 2\n```\n:::\n\n```{.r .cell-code}\n# degree distribution\ndegree_distribution(gr) # probability for degree 0,1,2,3,4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0 0.4 0.2 0.2 0.2\n```\n:::\n:::\n\n\n`strength` is weighted version of `degree`, by summing up the edge weights of the adjacent edges for each vertex.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add random weight attribute\nset.seed(12)\ngr2 <- gr %>% set_edge_attr(\n  \"weight\",index=E(gr),\n  value=sample(seq(0,1,0.05),size=length(E(gr)))\n)\n# calculate strength\nstrength(gr2, weights = E(gr)$weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.00 0.05 2.65 0.20 1.45 1.20 0.20 2.85 1.85 1.65\n```\n:::\n:::\n\n\n## Order/distance and path\n\nOrder measures the edge number from one node to the other. In `igraph` package, we use `distances` function to get order between two vertices. For directed graph, `in` mode only follow the paths toward the first node, while `out` mode goes away from the first node. If no connection can be made, `Inf` will be return.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# count all edges from 1 to 10, regardless of direction \ndistances(gr, v=1, to=10, mode=\"all\", weights = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    3\n```\n:::\n\n```{.r .cell-code}\n# pairwise distance table \ndistances(gr, mode=\"all\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    0    4    2  Inf    3    3  Inf    2    1     3\n [2,]    4    0    2  Inf    1    2  Inf    3    3     3\n [3,]    2    2    0  Inf    1    2  Inf    1    1     1\n [4,]  Inf  Inf  Inf    0  Inf  Inf    1  Inf  Inf   Inf\n [5,]    3    1    1  Inf    0    1  Inf    2    2     2\n [6,]    3    2    2  Inf    1    0  Inf    1    2     2\n [7,]  Inf  Inf  Inf    1  Inf  Inf    0  Inf  Inf   Inf\n [8,]    2    3    1  Inf    2    1  Inf    0    1     1\n [9,]    1    3    1  Inf    2    2  Inf    1    0     2\n[10,]    3    3    1  Inf    2    2  Inf    1    2     0\n```\n:::\n:::\n\n\nTo get detail route from one node to the other, we use `path`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# shortest path to connect\nall_shortest_paths(gr, 1,10)$res\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 4/10 vertices, from 2d81952:\n[1]  1  9  8 10\n\n[[2]]\n+ 4/10 vertices, from 2d81952:\n[1]  1  9  3 10\n```\n:::\n\n```{.r .cell-code}\n# all path to connect\nall_simple_paths(gr, 1,10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 7/10 vertices, from 2d81952:\n[1]  1  9  3  5  6  8 10\n\n[[2]]\n+ 5/10 vertices, from 2d81952:\n[1]  1  9  3  8 10\n\n[[3]]\n+ 4/10 vertices, from 2d81952:\n[1]  1  9  3 10\n\n[[4]]\n+ 5/10 vertices, from 2d81952:\n[1]  1  9  8  3 10\n\n[[5]]\n+ 7/10 vertices, from 2d81952:\n[1]  1  9  8  6  5  3 10\n\n[[6]]\n+ 4/10 vertices, from 2d81952:\n[1]  1  9  8 10\n```\n:::\n:::\n\n\n## Transitivity\n\n**Transitivity** measures the probability that the adjacent vertices of a vertex are connected. This is also called the **clustering coefficient**, a proxy to determine how well connected the graph is. This property is very important in social networks, and to a lesser degree in other networks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# two extreme classes -- full graph and ring graph\ng1 = make_full_graph(10)\nplot(g1)\n```\n\n::: {.cell-output-display}\n![](2019-08-24_network_analysis_part2_files/figure-html/Transitivity-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntransitivity(g1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ng2 = make_ring(10)\nplot(g2)\n```\n\n::: {.cell-output-display}\n![](2019-08-24_network_analysis_part2_files/figure-html/Transitivity-2.png){width=672}\n:::\n\n```{.r .cell-code}\ntransitivity(g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nThere are multiple different types of transitivity can be calculated (weighted or un-weighted). Also, the transitivity can be calculated locally for a sub-graph by specifying vertex ids. See details by `?transitivity`\n\n## Centrality\n\n**Centrality** indices identify the most important vertices within a graph. In other words, the \"hub\" of network. However, this \"importance\" can be conceived in two ways:\n\n-   relation to a type of flow or transfer across the network.\n-   involvement in the cohesiveness of the network\n\nThe simplest of centrality indicator is degree centrality (`centr_degree`), aka, a node is important if it has most neighbors.\n\nBesides degree centrality, there are\n\n-   closeness centrality (`centr_clo`) - a node is important if it takes the shortest mean distance from a vertex to other vertices\n-   between-ness centrality (`centr_betw`) - a node is important if extent to which a vertex lies on paths between other vertices are high.\n-   eigenvector centrality (`centr_eigen`) - a node is important if it is linked to by other important nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncentr_degree(gr, mode=\"all\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n [1] 1 1 4 1 3 2 1 4 3 2\n\n$centralization\n[1] 0.2\n\n$theoretical_max\n[1] 90\n```\n:::\n\n```{.r .cell-code}\ncentr_clo(gr, mode = \"all\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n [1] 0.3888889 0.3888889 0.7000000 1.0000000 0.5833333 0.5384615 1.0000000\n [8] 0.6363636 0.5833333 0.5000000\n\n$centralization\n[1] 0.8690613\n\n$theoretical_max\n[1] 4.235294\n```\n:::\n\n```{.r .cell-code}\ncentr_betw(gr, directed = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n [1] 0.0 0.0 8.0 0.0 6.5 1.0 0.0 4.5 6.0 0.0\n\n$centralization\n[1] 0.1666667\n\n$theoretical_max\n[1] 324\n```\n:::\n\n```{.r .cell-code}\ncentr_eigen(gr,directed = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vector\n [1] 2.519712e-01 1.933127e-01 1.000000e+00 2.093280e-17 5.762451e-01\n [6] 5.244145e-01 1.036823e-17 9.869802e-01 7.511000e-01 6.665713e-01\n\n$value\n[1] 2.980897\n\n$options\n$options$bmat\n[1] \"I\"\n\n$options$n\n[1] 10\n\n$options$which\n[1] \"LA\"\n\n$options$nev\n[1] 1\n\n$options$tol\n[1] 0\n\n$options$ncv\n[1] 0\n\n$options$ldv\n[1] 0\n\n$options$ishift\n[1] 1\n\n$options$maxiter\n[1] 1000\n\n$options$nb\n[1] 1\n\n$options$mode\n[1] 1\n\n$options$start\n[1] 1\n\n$options$sigma\n[1] 0\n\n$options$sigmai\n[1] 0\n\n$options$info\n[1] 0\n\n$options$iter\n[1] 8\n\n$options$nconv\n[1] 1\n\n$options$numop\n[1] 26\n\n$options$numopb\n[1] 0\n\n$options$numreo\n[1] 16\n\n\n$centralization\n[1] 0.6311756\n\n$theoretical_max\n[1] 8\n```\n:::\n:::\n\n\nMany other centrality indicators refer to [wiki page of Centrality](https://en.wikipedia.org/wiki/Centrality).\n\n# Graph clustering\n\nGraph clustering is the most useful calculation that can be done in `igraph` object. There are a whole line of research on this. Only basic clustering methods were covered here.\n\n## decompose graph\n\nTo split graph into connected sub-graph, `decompose.graph` calculates the connected components of your graph. A **component** is a sub-graph in which all nodes are inter-connected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# decompose graph to connected components\ndg <- decompose.graph(gr)\ndg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\nIGRAPH 9072470 U--- 8 10 -- Erdos-Renyi (gnp) graph\n+ attr: name (g/c), type (g/c), loops (g/l), p (g/n)\n+ edges from 9072470:\n [1] 2--4 3--4 4--5 3--6 5--6 1--7 3--7 6--7 3--8 6--8\n\n[[2]]\nIGRAPH cea9efc U--- 2 1 -- Erdos-Renyi (gnp) graph\n+ attr: name (g/c), type (g/c), loops (g/l), p (g/n)\n+ edge from cea9efc:\n[1] 1--2\n```\n:::\n\n```{.r .cell-code}\n# summary statics graph components\ncomponents(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$membership\n [1] 1 1 1 2 1 1 2 1 1 1\n\n$csize\n[1] 8 2\n\n$no\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n# plot components\ncoords <- layout_(gr, nicely())\nplot(gr, layout=coords,\n     mark.groups = split(as_ids(V(gr)), components(gr)$membership)\n     )\n```\n\n::: {.cell-output-display}\n![](2019-08-24_network_analysis_part2_files/figure-html/decompose-1.png){width=672}\n:::\n:::\n\n\n## Cliques\n\n**Clique** is a special sub-graph in which every two distinct vertices are adjacent. The direction is usually ignored for clique calculations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract cliques that contain more than 3 vertices\ncliques(gr, min=3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 3/10 vertices, from 2d81952:\n[1]  3  8 10\n\n[[2]]\n+ 3/10 vertices, from 2d81952:\n[1] 3 8 9\n```\n:::\n\n```{.r .cell-code}\n# get cliques with largest number of vertices\nlargest_cliques(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 3/10 vertices, from 2d81952:\n[1] 8 3 9\n\n[[2]]\n+ 3/10 vertices, from 2d81952:\n[1]  8  3 10\n```\n:::\n\n```{.r .cell-code}\n# plot cliques\ncl <- cliques(gr, 3)\n\ncoords <- layout_(gr, nicely())\nplot(gr, layout=coords,\n     mark.groups=lapply(cl, function(g){as_ids(g)}), \n     mark.col=c(\"#C5E5E7\",\"#ECD89A\"))\n```\n\n::: {.cell-output-display}\n![](2019-08-24_network_analysis_part2_files/figure-html/clique-1.png){width=672}\n:::\n:::\n\n\n## Communities and modules\n\nGraph **communities structure** is defined if the nodes of the network can be easily grouped into (potentially overlapping) sets of nodes such that each set of nodes is densely connected internally. **Modularity** is always used as a measure the strength of division of a network into community for optimization methods in detecting community structure in networks.\n\nThere are many algorithms to cluster graph to communities.\n\n-   `cluster_edge_betweenness` a hierarchical decomposition process where edges are removed in the decreasing order of their edge betweenness scores.\\\n-   `cluster_optimal` - a top-down hierarchical approach that optimizes the modularity function\n-   `cluster_walktrap` - an approach based on random walks\n-   `cluster_fast_greedy`\n-   `cluster_label_prop`\n-   `cluster_leading_eigen`\n-   `cluster_Louvain`\n-   `cluster_spinglass`\n\nWhich cluster method to use? Refer to this [stackoverflow post](https://stackoverflow.com/questions/9471906/what-are-the-differences-between-community-detection-algorithms-in-igraph) for more information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# cluster graph using walktrap method, turn a ”communities” object\nwtc <- cluster_walktrap(gr) \nwtc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH clustering walktrap, groups: 3, mod: 0.33\n+ groups:\n  $`1`\n  [1]  1  3  8  9 10\n  \n  $`2`\n  [1] 2 5 6\n  \n  $`3`\n  [1] 4 7\n  \n```\n:::\n\n```{.r .cell-code}\n# find membership for each vertex\nmembership(wtc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 1 3 2 2 3 1 1 1\n```\n:::\n\n```{.r .cell-code}\n# calculate modularity for walktrap clustering on this graph\nmodularity(wtc) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3305785\n```\n:::\n\n```{.r .cell-code}\n# plot community\ncoords <- layout_(gr, nicely())\nplot(wtc, gr, layout=coords)\n```\n\n::: {.cell-output-display}\n![](2019-08-24_network_analysis_part2_files/figure-html/community-1.png){width=672}\n:::\n:::\n\n\nTo learn more about graph clustering:\n\n1.  [NCSU course slide Introduction to Graph Cluster Analysis](https://www.csc2.ncsu.edu/faculty/nfsamato/practical-graph-mining-with-R/slides/pdf/Graph_Cluster_Analysis.pdf)\n\n2. [MIT open course Finding Clusters in Graphs](https://www.youtube.com/watch?v=cxTmmasBiC8)\n",
    "supporting": [
      "2019-08-24_network_analysis_part2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
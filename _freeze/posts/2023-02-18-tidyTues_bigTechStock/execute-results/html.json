{
  "hash": "e02ab5dd077f58ce04c4ad20de969198",
  "result": {
    "markdown": "---\ntitle: \"Buy low sell high on big tech stock?\"\nauthor: \"Chun Su\"\ndate: \"2023-02-18\"\ncategories: [\"R\", \"tidyTuesday\"]\nexecute: \n  eval: false\n  warning: false\n  message: false\nformat:\n  html:\n      code-fold: false\n      code-overflow: wrap\nimage: \"https://github.com/sckinta/learningwithsckinta_quartoblog/raw/main/_freeze/posts/2023-01-16-survival_analysis/figure-html/unnamed-chunk-5-1.png\"\n---\n\n\nI am interested in [Big Tech Stock Prices](https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-02-07/readme.md) since I personally hold several big Tech stocks and experienced bloody plummeting in the last year. As an amateur investor, I have been always questioning my investing strategies, and wondering how different strategies result in the gains. Retrospect analysis is a good way to answer the question partially. \n\nIn this TidyTuesday exercise, I will use strategy of \"buy low sell high\" at 52 weeks cycle on these big tech stocks, and see which company fits this strategy the best.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate)\ntheme_set(theme_bw())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_tech_stock_prices <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-02-07/big_tech_stock_prices.csv')\nbig_tech_companies <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2023/2023-02-07/big_tech_companies.csv')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# library(quantmod)\nload(\"~/Documents/Untitled.rdata\")\nstock_symbol <- 'AAPL'\n```\n:::\n\n\n# Example of \"buy low sell high\" strategy in APPL\n\nTo compose functions, I will use Apple stock (APPL) as an example. Starting from the earliest available date, observe for one period (52 weeks), then start to invest afterwards.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstock_symbol <- 'AAPL'\n\nperiod <- 52*7\n\n# first date ready to invest\nstart_date <- big_tech_stock_prices |> \n    filter(stock_symbol==!!stock_symbol) |> \n    slice(which.min(date)) |> \n    mutate(date = as.character(date + period)) |> \n    pull(date) |> \n    as.Date() # \"2011-01-03\"\n\n# data.frame ready to invest\ndf <- big_tech_stock_prices |> \n    filter(stock_symbol==!!stock_symbol, date >= start_date)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-02-18-tidyTues_bigTechStock_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n## step 1: determine high and low point within period sliding window\n\nFirst step is to find 52 week low and high for each date, and determine whether a given date is 52 week low/high or not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndetermine_period_low_high <- function(df, period=354){\n    \n    stock_symbol <- df |>\n        distinct(stock_symbol) |>\n        pull(stock_symbol)\n    \n    wk52_low_high <- map_dfr(\n        df$date,\n        ~big_tech_stock_prices |> \n            filter(stock_symbol==!!stock_symbol, date <= .x, date > .x - period) |> \n            summarise(\n                low_wk52 = min(low),\n                high_wk52 = max(high)\n            ) |> \n            mutate(date=.x)\n    )\n    \n    df <- left_join(df, wk52_low_high) |> \n        mutate(\n            is_wk52_low = ifelse(low==low_wk52, T, F),\n            is_wk52_high = ifelse(high==high_wk52, T, F)\n        )\n    df\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- determine_period_low_high(df)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-02-18-tidyTues_bigTechStock_files/figure-html/plot_determine_period_low_high-1.png){width=672}\n:::\n:::\n\n\n\n## step 2: transaction date and price if have unlimited money\n\nEven there are so many high and low points, since we sell everything at each transaction cycle, thus we can use first high point right after low points (buy points) to sell. If we have multiple low points in row, we will keep buying until we run out money.\n\nTo simplify the problem, we first assume we have unlimited cash, and determine buy and sell points from the high and low points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndetermine_buy_sell_unlimited <- function(df){\n    # shorten df to have only possible low/high point and start with a wk52 low point\n    df2 <- df |>\n        filter(is_wk52_low | is_wk52_high) |>\n        filter(cumsum(is_wk52_low) > 0)\n    \n    # create empty sell_df\n    sell_df <- NULL\n    \n    # loop through df2 get all possible sell_df (since buy at all low points when with unlimited cash) - the first high after lows\n    while(nrow(df2) > 0) {\n        sell_df <- bind_rows(\n            sell_df,\n            df2 |>\n                filter(cumsum(is_wk52_high) == 1) |> # the first high after lows\n                select(stock_symbol, date, price = high)\n        )\n        \n        df2 <- df2 |>\n            filter(date > max(sell_df$date)) |>\n            filter(cumsum(is_wk52_low) > 0) # shorten df2 to have only possible low/high point and start with next wk52 low point\n        \n        if (all(df2$is_wk52_low)) {\n            break\n        }\n    }\n    \n    # create transaction_df by combining sell_df with buy_df\n    transaction_df <- df |>\n        filter(is_wk52_low) |>\n        select(stock_symbol, date, price = low) |>\n        mutate(transaction = \"buy\") |>\n        bind_rows(sell_df |>\n                      mutate(transaction = \"sell\")) |>\n        arrange(date)\n    \n    # adding transaction cycle (using sell as end of one cycle)\n    transaction_df <- transaction_df |>\n        left_join(transaction_df |>\n                      filter(transaction == \"sell\") |>\n                      mutate(cycle = row_number())) |>\n        fill(cycle, .direction = \"up\") |>\n        group_by(cycle) |>\n        mutate(cycle = cur_group_id()) |>\n        ungroup()\n    \n    transaction_df\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransaction_df <- determine_buy_sell_unlimited(df)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-02-18-tidyTues_bigTechStock_files/figure-html/plot_determine_buy_sell-1.png){width=672}\n:::\n:::\n\n\n## step 3: determine final sell/buy points and transaction details\n\nThe investment strategy (\"buy low sell high\") have 4 options based on the different assumptions:\n\n1. assuming you have unlimited of money, from the time ready to invest, always buy same number of stocks (`num_per_buy`) at 52 week low, and sell everything hold at 52 week high\n\n2. assuming you have unlimited of money and you can buy stock bits (but have to sell as whole), from the time ready to invest, always spent same amount of cash (`cash_per_buy`) to buy at 52 week low, and sell everything hold at 52 week high.\n\n3. assuming you have a fixed amount of money (`total_cash`), from the time ready to invest, always buy same number of stocks (`num_per_buy`) at 52 week low, and sell everything hold at 52 week high.\n\n4. assuming you have a fixed amount of money (`total_cash`) and you can buy stock bits (but have to sell as whole), from the time ready to invest, always spent same amount of cash (`cash_per_buy`) to buy at 52 week low, and sell everything hold at 52 week high.\n\nThe transaction details include 1) how many stocks to buy/sell and 2) how much cash to spend/earn at each transaction. Depending on the invest options mentioned above, we create transaction detail for each option.\n\n*Note:*\n\n1. To simplify the problem, we always buy same number of stocks for option 3. If there is not enough, drop the whole buy transaction instead of buying smaller number of stocks.\n\n2. Although stocks can be bought in bits but must be sold as whole.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuy_low_sell_high <- function(transaction_df, cash_limit=Inf, num_per_buy, cash_per_buy=NULL){\n    \n    if(is.infinite(cash_limit)){\n        # option 1: unlimited cash, buy whole stock with fixed number\n        if(!is.null(num_per_buy)){\n            buy_df <- transaction_df |>\n                filter(transaction == \"buy\") |>\n                mutate(stock_num = num_per_buy) |>\n                mutate(stock_cash = -stock_num * price)\n        # option 2: unlimited cash, buy bit stock with fixed cash\n        }else if(!is.null(cash_per_buy)){\n            buy_df <- transaction_df |>\n                filter(transaction == \"buy\") |>\n                mutate(stock_cash = -cash_per_buy) |>\n                mutate(stock_num = -stock_cash / price)\n        }\n        \n        # sell_df will be same for option 1 and option 2: at each cycle sell most whole stocks\n        sell_df <- transaction_df |>\n            filter(transaction == \"sell\") |>\n            left_join(buy_df |>\n                          group_by(cycle) |>\n                          summarise(stock_num = -floor(sum(stock_num)))) |>  # can only sell whole stocks)\n            mutate(stock_cash = -price * stock_num)\n        \n        transaction_df2 <- bind_rows(buy_df,\n                                     sell_df) |>\n            arrange(date) |>\n            mutate(\n                stock_num_cumsum = cumsum(stock_num),\n                stock_cash_cumsum = cumsum(stock_cash)\n            )\n    }else{\n        \n        transaction_df2 <- NULL\n        total_cash <- cash_limit\n        # for each transaction cycle, has to cut off some buys to make sure stock_cash_cumsum > 0\n        for (i in unique(transaction_df$cycle)) {\n            # option 3: limited cash, buy whole stock with fixed number\n            if(!is.null(num_per_buy)){\n                buy_df <- transaction_df |>\n                    filter(transaction == \"buy\", cycle == i) |>\n                    mutate(stock_num = num_per_buy) |>\n                    mutate(stock_cash = -stock_num * price) |>\n                    mutate(\n                        stock_num_cumsum = cumsum(stock_num),\n                        stock_cash_cumsum = cumsum(stock_cash)\n                    ) |>\n                    mutate(stock_cash_cumsum = total_cash + stock_cash_cumsum) |>\n                    filter(cumsum(stock_cash_cumsum >= 0) == row_number())\n                \n            # option 4: unlimited cash, buy bit stock with fixed cash\n            }else if(!is.null(cash_per_buy)){\n                buy_df <- transaction_df |>\n                    filter(transaction == \"buy\", cycle == i) |>\n                    mutate(stock_cash = -cash_per_buy) |>\n                    mutate(stock_num = -stock_cash / price) |>\n                    mutate(\n                        stock_num_cumsum = cumsum(stock_num),\n                        stock_cash_cumsum = cumsum(stock_cash)\n                    ) |>\n                    mutate(stock_cash_cumsum = total_cash + stock_cash_cumsum) |>\n                    filter(cumsum(stock_cash_cumsum >= 0) == row_number())\n            }\n            \n            \n            if (nrow(buy_df) == 0) {\n                break\n            } else{\n                sell_df <- transaction_df |>\n                    filter(transaction == \"sell\", cycle == i) |>\n                    left_join(buy_df |>\n                                  group_by(cycle) |>\n                                  summarise(stock_num = -floor(sum(stock_num)))) |>\n                    mutate(stock_cash = -price * stock_num)\n                \n                transaction_df2 <- bind_rows(\n                    transaction_df2,\n                    bind_rows(buy_df,\n                              sell_df) |>\n                        arrange(date) |>\n                        mutate(\n                            stock_num_cumsum = cumsum(stock_num),\n                            stock_cash_cumsum = total_cash + cumsum(stock_cash)\n                        )\n                )\n                \n                # update total cash after one cycle\n                total_cash <-\n                    transaction_df2 |> slice(n()) |> pull(stock_cash_cumsum)\n            }\n        }\n    }\n    transaction_df2\n}\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nTo make options comparable across, we set `cash_limit` as 1000, `num_per_buy` as 10 and `cash_per_buy` as 1000, and being consistent across all the options and stocks.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncash_limit <- 1000\nnum_per_buy <- 10\ncash_per_buy <- 1000\n```\n:::\n\n\n### option 1: unlimited cash, buy whole stock with fixed number\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransaction_df1 <- buy_low_sell_high(transaction_df, cash_limit=Inf, num_per_buy=num_per_buy, cash_per_buy=NULL)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-02-18-tidyTues_bigTechStock_files/figure-html/plot_option1-1.png){width=672}\n:::\n:::\n\n\n### option 2: unlimited cash, buy bit stock with fixed cash\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransaction_df2 <- buy_low_sell_high(transaction_df, cash_limit=Inf, num_per_buy=NULL, cash_per_buy=cash_per_buy)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-02-18-tidyTues_bigTechStock_files/figure-html/plot_option2-1.png){width=672}\n:::\n:::\n\n\n### option 3: limited cash, buy whole stock with fixed number\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransaction_df3 <- buy_low_sell_high(transaction_df, cash_limit=cash_limit, num_per_buy=num_per_buy, cash_per_buy=NULL)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-02-18-tidyTues_bigTechStock_files/figure-html/plot_option3-1.png){width=672}\n:::\n:::\n\n\n### option 4: unlimited cash, buy bit stock with fixed cash\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntransaction_df4 <- buy_low_sell_high(transaction_df, cash_limit=cash_limit, num_per_buy=NULL, cash_per_buy=cash_per_buy)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](2023-02-18-tidyTues_bigTechStock_files/figure-html/plot_option4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n\n# Which option is better?\n\nTo determine which option is better, we have to evaluate investment outcome by gain-risk ratio. The simple gain-risk ratio can be estimated by the earned cashed divided by required input.\n\n\n::: {.cell}\n\n```{.r .cell-code}\neval_df <- left_join(\n    # stock_cash_cumsum reported for all options\n    list(transaction_df1,\n         transaction_df2,\n         transaction_df3,\n         transaction_df4) |>\n        map_dfr(~ .x |>\n                    filter(transaction == \"sell\") |>\n                    slice(n()) |>\n                    select(stock_cash_cumsum)) |>\n        mutate(option = row_number()) |>\n        mutate(option = glue::glue(\"option_{option}\")),\n    \n    # required_input money\n    list(transaction_df1,\n         transaction_df2) |>\n        map_dfr( ~ .x |>\n                     slice(1:max(which(stock_num < 0))) |>\n                     filter(stock_cash_cumsum < 0) |> \n                     summarise(required_input = max(abs(stock_cash_cumsum)))) |> \n    mutate(option = row_number()) |> \n    mutate(option = glue::glue(\"option_{option}\"))\n) |> \n    mutate(money_gain = ifelse(is.na(required_input), stock_cash_cumsum-cash_limit, stock_cash_cumsum)) |> # the last stock_cash_cumsum include the input cash in option 3/4\n    mutate(required_input=ifelse(is.na(required_input), cash_limit, required_input)) |> \n    select(-stock_cash_cumsum)\n\neval_df |> \n    mutate(gain_risk_ratio = money_gain/required_input) |> \n    knitr::kable(caption = \"gain-risk ratio for buy-low-sell-high options\")\n```\n\n::: {.cell-output-display}\nTable: gain-risk ratio for buy-low-sell-high options\n\n|option   | required_input| money_gain| gain_risk_ratio|\n|:--------|--------------:|----------:|---------------:|\n|option_1 |       1038.279|   1186.071|       1.1423441|\n|option_2 |       7000.000|   5021.631|       0.7173759|\n|option_3 |       1000.000|   1124.204|       1.1242036|\n|option_4 |       1000.000|   1003.605|       1.0036046|\n:::\n:::\n\n\n\nFor APPL, it seems buy same whole stock each buy is better strategy than spending fixed money at 52 week low. If you cannot get more than \\$1000, option 3 -- with limited cash (only $1000), buy whole stock with fixed number --is the best strategy. It spend least amount of input money (low risk) to get reasonable gain.\n\n# Which big tech gave best gain using buy-low-sell-high option 3?\n\nAbove we use Apple stock (APPL) as an example, from the earliest available date, observe for one period (52 weeks), then ready to invest.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncash_limit <- 1000\nnum_per_buy <- 10\ncash_per_buy <- 1000\nperiod <- 364\n\ndf_all_tech <- big_tech_stock_prices |> \n            group_by(stock_symbol) |> \n            slice(which.min(date)) |> \n            ungroup() |> \n            select(stock_symbol, start_date=date) |> \n            left_join(\n                big_tech_stock_prices\n            ) |> \n            filter(date >= start_date + period) |> \n            select(-start_date)\n\ndf_all_tech <- split(df_all_tech, df_all_tech$stock_symbol)\n\n\ntransaction_df_all_tech <-\n    map_dfr(names(df_all_tech),\n            function(tech_symbol) {\n                cat(paste(\"START\", tech_symbol, \"\\n\"))\n                df <- df_all_tech[[tech_symbol]]\n                cat(\"run determine_period_low_high...\\n\")\n                step1_df <- determine_period_low_high(df)\n                cat(\"run determine_buy_sell_unlimited...\\n\")\n                step2_transaction_df <-\n                    determine_buy_sell_unlimited(step1_df)\n                cat(\"run buy_low_sell_high...\")\n                buy_low_sell_high(\n                    step2_transaction_df,\n                    cash_limit = cash_limit,\n                    num_per_buy = num_per_buy,\n                    cash_per_buy = NULL\n                )\n            })\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntransaction_df_all_tech |> \n    filter(transaction==\"sell\") |> \n    group_by(stock_symbol) |> \n    slice(n()) |> \n    select(stock_symbol, stock_cash_cumsum) |> \n    mutate(money_gain = stock_cash_cumsum-1000) |> \n    mutate(required_input = 1000) |> \n    mutate(gain_risk_ratio = money_gain/required_input) |> \n    knitr::kable(caption = \"\")\n```\n:::\n\n\n|stock_symbol | stock_cash_cumsum| money_gain| required_input| gain_risk_ratio|\n|:------------|-----------------:|----------:|--------------:|---------------:|\n|AAPL         |          2124.204|  1124.2036|           1000|       1.1242036|\n|ADBE         |          1709.500|   709.5001|           1000|       0.7095001|\n|AMZN         |          1382.835|   382.8350|           1000|       0.3828350|\n|CRM          |          2639.075|  1639.0750|           1000|       1.6390750|\n|CSCO         |          1373.400|   373.4001|           1000|       0.3734001|\n|GOOGL        |          1896.720|   896.7201|           1000|       0.8967201|\n|INTC         |          1792.600|   792.6001|           1000|       0.7926000|\n|MSFT         |          1143.500|   143.5000|           1000|       0.1435000|\n|NFLX         |          1190.714|   190.7142|           1000|       0.1907142|\n|NVDA         |          1241.575|   241.5750|           1000|       0.2415750|\n|ORCL         |          1566.400|   566.4000|           1000|       0.5664000|\n|TSLA         |          2201.067|  1201.0667|           1000|       1.2010667|\n\n*Note: The reason \"META\" and \"IBM\" failed to show because they were too expensive to buy at their first 52 weeks low (10 stocks were already beyond my cash limit)!!!*\n\n\n# Final thoughts\n\nDue to the time limit, I will end this TidyTuesday exercise here. However, there are till many interesting ideas to explore.\n\n1. If we adjust parameters in the \"buy-low-sell-high\" strategy, eg: `start_date`, `period`, `cash_limit`, `num_per_buy` and `cash_per_buy`, will it make gain-risk-ratio change dramatically within the same stock? Just like I tune hyper-parameters in ML exercise!\n\n2. The current model did not take taxes (which is a big expense in trading) into consideration. How long to hold a stock determines tax brackets. It will improve the estimate accuracy of true gain.\n\n3. All the price of big tech stocks were slowly climbing up at early time. Will my functions break if the stock kept dropping?\n\n4. All the price of big tech stocks are quite stable. Will a more fluctuated stock make difference on the \"buy-low-sell-high\" strategy?\n\n5. I did not use this strategy in my personal trading. Instead, I just invest fixed amount of cash into index fund recurrently with a certain frequency. How about writing the \"recurrent invest\" strategy and comparing this to \"buy-low-sell-high\" strategy?\n\nAt R-ladies Philly event, Alice mentioned a R package `{quantmod}` to download daily price for any stocks and perform quantitative financial modeling. I may want to try it out sometime.\n\nBesides the stock context itself, I have a few final take-away from this exercise:\n\n1. When question is complicated, I should modularize the question and solve the big question by accomplishing little steps first.\n\n  - Modular programming is one-step towards object-oriented programming, although there are difference between modular programming and object-oriented programming [^1].\n  \n  - I had to spend an extra night to clean up the code to make everything function-based (object-oriented?). However, just like writing paper, spitting it out is always the hardest but also the very first step. Do not worry about the coding style at beginning, just spit it out! \n  \n2. As usually, I picked up several tricks to \"filter\" the rows. \n\n  - using `filter(cumsum(<boolean>) ...)`\n  \n    - `filter(cumsum(is_wk52_low) > 0)`: remove the first x rows where `is_wk52_low` is `FALSE` (but not removing anything after is_wk52_low being `TRUE` once)\n    \n    - `filter(cumsum(is_wk52_high) == 1)`: remove everything after `is_wk52_high` is `TRUE` for the first time \n    \n    - `filter(cumsum(stock_cash_cumsum >= 0) == row_number())`: remove everything after `stock_cash_cumsum >= 0` is `FALSE` for the first time (note: different from simple `filter(stock_cash_cumsum >=0)` by even removing `stock_cash_cumsum >=0` cases after first `FALSE` case)\n    \n  - using `slice()`\n  \n    - `slice(n())`: just keep last row\n    \n    - `slice(1:max(which(stock_num < 0)))`: keep first row until the last row where `stock_num < 0`\n\n\n[^1]: [What is the big difference between modular and object oriented programming?](https://stackoverflow.com/questions/18034683/what-is-the-big-difference-between-modular-and-object-oriented-programming#:~:text=Modular%20programming%20(also%20called%20%22top,aspect%20of%20the%20desired%20functionality.)",
    "supporting": [
      "2023-02-18-tidyTues_bigTechStock_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
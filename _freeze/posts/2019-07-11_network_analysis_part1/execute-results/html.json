{
  "hash": "64df9bed5126ebd448487910c9ba870c",
  "result": {
    "markdown": "---\ntitle: \"Network Analysis in R - Part 1\"\ndate: \"2019-07-11\"\ncategories: [R, network]\nexecute:\n  echo: true\n  warning: false\n  message: false\n  code-overflow: wrap\nimage: \"https://www.robcross.org/wp-content/uploads/2020/06/organizational-network-analysis.png\"\n---\n\n\nNetwork analysis, also called graph analysis, is to study the complexity of the inter-relationships between actors of all sorts and provides an architectural view of individual actor connections.\n\nIt has been applied to many fields, like social network and gene network, and useful for any systematic studies on individual relationship [^1].\n\n[^1]: https://en.wikipedia.org/wiki/Graph_theory\n\nI will create a three part series [^2] of network analysis and visualization using R packages `{igraph}` and `{ggraph}`. In this post, I will focus on general introduction of the terminology and R objects used in network analysis.\n\n[^2]: Here are [part-2](https://learniningwithsckinta.netlify.com/post/network_analysis_part2-2/) and [part-3](https://learniningwithsckinta.netlify.com/post/network_analysis_part3/)\n\n# Glossaries\n\n-   **Vertex**: is the node of network.\n\n-   **Edge**: the connection of notes, sometimes called \"linked\". The edge can be **directed** or **undirected**, depending on whether the distinction between source and target is meaningful.\n\n-   **Graph**: constitute of vertex and edges, which represents the whole inter-relationship of nodes. The **subgraph**, from the other hand, represents the inter-relationship of a subset of nodes.\n\n-   **Cliques**: Fully connected sub-graphs of a graph in which the every vertex connects with every other vertex.\n\n-   **Degree** : the number of adjacent vertex.\n\n-   **Order** : how far away from one vertex to another. order 0 is always v itself, order 1 is v plus its immediate neighbors, order 2 is order 1 plus the immediate neighbors of the vertices in order 1, etc.\n\n-   **Attribute**: attributes are associated with either vertex or edge. By default, the `name` is the mandatory attribute for vertex and edge. If the edges have a magnitude attribute, the graph is considered **weighted**.\n\n-   **Bipartite networks**: two-mode networks, in which there are two types of vertex and connections are only allowed between different types of nodes. Thus, `type` is a mandatory vertex attribute for bipartite networks. There are two types of common used bipartite networks:\n\n    1)  Two types of vertex are annotated either \"**individual**\" or \"**group**\" to which the individual belong to. This is also called \"affiliation network\".\n\n    2)  the network consistent of two \"**parallel**\" types of vertex, in which type 1 only interact with type 2 while no interactions happen within the same type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(igraph)\nlibrary(tidyverse)\nlibrary(ggraph)\nlibrary(gridExtra)\n```\n:::\n\n\n# IGRAPH object\n\n**IGRAPH object** is a R object defined in `igraph` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_graph(letters[1:10], directed = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH be34cdf DN-- 10 5 -- \n+ attr: name (v/c)\n+ edges from be34cdf (vertex names):\n[1] a->b c->d e->f g->h i->j\n```\n:::\n:::\n\n\nThe first line of IGRAPH `IGRAPH dca479d DN-- 10 5 --` means a graph with id `dca479d` is *directed* (`D`) and *named* (`N`) containing `10` *vertices* and `5` *edges*.\n\nThe second line `+ attr: name (v/c)` indicates the attributes associated with vertex (`v`) and/or edge (`e`). In our example, only vertex has attribute `name` which is a character variable (`c`).\n\nThe third and fourth line of IGRAPH literally print what edges are. In our case, since graph is directed, the arrow shows the direction of edge.\n\nIt is worth to mention that the name of edges can be listed by vertices name in a `from|to` format. In most cases, names are the default attributes for vertex and can be used just like index to extract information directly from `IGRAPH` object. We will discuss this in detail in \"graph subset\" session.\n\n# IGRAPH object manipulation\n\n## Create a graph\n\nThere are many ways to create graph from scratch.\n\n-   Easy graph:`graph_from_literal`, `make_graph`\n\n-   Create from user data: `graph_from_edgelist`, `graph_from_adjacency_matrix`, `graph_from_data_frame`\n\n-   Random graphs: `sample_gnp`, `sample_gnm`, `sample_pa`, `sample_smallworld`, etc.\n\nThe following are a few examples of ways frequently used by me to make graph .\n\n### edge list matrix\n\nThe example below generates a directed graph from a list of vertex pair (edge)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedge_list <-\n    data.frame(from = c(1, 2, 2, 3, 4), to = c(2, 3, 4, 2, 1)) %>% \n    as.matrix()\n\ng <- graph_from_edgelist(edge_list,directed = TRUE)\n\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 59ad3e6 D--- 4 5 -- \n+ edges from 59ad3e6:\n[1] 1->2 2->3 2->4 3->2 4->1\n```\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n### one-mode graph from a vector of edge\n\nIf the edge is given in a single vector, the default `make_graph` will use the order of vector to make one-mode graph. It means that the 1st edge points from the 1st element to the 2nd element, the 2nd edge from the 3rd element to the 4th element, etc. If the length of vector is odd number, it will end with last element connecting back to the 1st element, and throw a warning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- make_graph(letters[1:10], directed = T)\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 12185c3 DN-- 10 5 -- \n+ attr: name (v/c)\n+ edges from 12185c3 (vertex names):\n[1] a->b c->d e->f g->h i->j\n```\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n### using adjacent matrix\n\nThe example below generates a undirected graph from a binary matrix, in which nodes are matrix colname and rowname.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nadj_matrix <-\n    matrix(sample(0:1, 100, replace = TRUE, prob = c(0.8, 0.1)), nc = 10)\n\ncolnames(adj_matrix) <- letters[1:10]\n\nrownames(adj_matrix) <- letters[1:10]\n\nadj_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a b c d e f g h i j\na 0 1 1 1 0 0 0 0 0 0\nb 0 0 0 1 0 0 0 0 0 0\nc 0 0 0 0 0 0 0 0 0 0\nd 0 0 1 0 0 0 0 0 0 0\ne 1 0 0 0 0 0 0 0 0 0\nf 0 1 0 0 0 0 0 0 0 0\ng 0 0 0 0 0 0 0 0 1 0\nh 1 0 0 0 0 0 0 0 1 0\ni 0 0 0 0 0 1 0 0 0 0\nj 0 1 0 0 0 0 0 0 0 0\n```\n:::\n\n```{.r .cell-code}\ng <-\n    graph_from_adjacency_matrix(adj_matrix, mode = \"undirected\", weighted = T)\n\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 81fe3c0 UNW- 10 12 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 81fe3c0 (vertex names):\n [1] a--b a--c a--d a--e a--h b--d b--f b--j c--d f--i g--i h--i\n```\n:::\n\n```{.r .cell-code}\nplot(g)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThere are other modes [^3] available with details.\n\n[^3]: https://igraph.org/r/doc/graph_from_adjacency_matrix.html\n\n### Using named data.frame\n\nThis is my favorite. The graph generated from `data.frame` can add all attributes at once. The below example is from official website. The attributes for nodes (`actors`) are `age` and `gender`, and edge (`relationship`) attributes include `same.dept`, `friendship` and `advice`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactors <- data.frame(\n  name=c(\"Alice\", \"Bob\", \"Cecil\", \"David\",\"Esmeralda\"),\n  age=c(48,33,45,34,21),\n  gender=c(\"F\",\"M\",\"F\",\"M\",\"F\"))\n\nrelations <- data.frame(\n  from=c(\"Bob\", \"Cecil\", \"Cecil\", \"David\",\"David\", \"Esmeralda\"),\n  to=c(\"Alice\", \"Bob\", \"Alice\", \"Alice\", \"Bob\", \"Alice\"),\n  same.dept=c(FALSE,FALSE,TRUE,FALSE,FALSE,TRUE),\n  friendship=c(4,5,5,2,1,1), \n  advice=c(4,5,5,4,2,3)\n  )\n\nactor_relation_g <- graph_from_data_frame(relations, directed=TRUE, vertices=actors)\n\nactor_relation_g\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 05d16d7 DN-- 5 6 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 05d16d7 (vertex names):\n[1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice\n[5] David    ->Bob   Esmeralda->Alice\n```\n:::\n\n```{.r .cell-code}\nplot(actor_relation_g)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/graphDataFrame-1.png){width=672}\n:::\n:::\n\n\n### Create random graph\n\nRandom graph generation is useful when it comes to simulation.\n\n-   `sample_gnp` and `sample_gnm` generate random graph by assuming the same constant probability for every possible edge.\n\n    -   The required parameters for *gnp* include: 1) The number of vertices in the graph `n` and 2) The probability for drawing an edge between two arbitrary vertices `p`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sample 10 vertex, every possible edge is created with the same constant probability 0.3\nset.seed(12)\ngr <- sample_gnp(10, 0.3)\ngr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH eaef67a U--- 10 11 -- Erdos-Renyi (gnp) graph\n+ attr: name (g/c), type (g/c), loops (g/l), p (g/n)\n+ edges from eaef67a:\n [1] 2-- 5 3-- 5 5-- 6 4-- 7 3-- 8 6-- 8 1-- 9 3-- 9 8-- 9 3--10 8--10\n```\n:::\n\n```{.r .cell-code}\nplot(gr)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n    -  The required parameters for *gmp* include: 1) The number of vertices in the graph `n` and 2) The number of edges in the graph `m`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sample 10 vertex, create a 15-edge graph\nset.seed(123)\ngr <- sample_gnm(10, 15)\ngr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH a2ec496 U--- 10 15 -- Erdos-Renyi (gnm) graph\n+ attr: name (g/c), type (g/c), loops (g/l), m (g/n)\n+ edges from a2ec496:\n [1] 1-- 2 1-- 4 2-- 4 3-- 4 5-- 6 2-- 7 3-- 7 5-- 7 2-- 8 3-- 8 6-- 8 1-- 9\n[13] 4-- 9 5--10 9--10\n```\n:::\n\n```{.r .cell-code}\nplot(gr)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n-   Random scale free network, which means a network whose degree of nodes distribution follows a power law. `sample_pa` generates scale-free graphs according to the Barabasi-Albert model. We start with a single vertex and no edges in the first time step. Then we add one vertex in each time step and the new vertex initiates some edges to old vertices. The probability that an old vertex is chosen is given by $p(i) ~ k_i * power + zero.appeal$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\ngr <- sample_pa(100, power = 2)\n\nplot(g, vertex.label= NA, edge.arrow.size=0.02,vertex.size = 0.5)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(density(degree_distribution(gr)))\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n:::\n\n\nThere are many other random graphs using different models. To find more, try `?igraph::sample_[TAB]`.\n\n## Extract vertex/edge and their attributes\n\nTo get vertex list and their attributes from graph object, we use `V(graph)$\"<attribute_name>\"` to convert graph object to vector. Using IGRAPH `actor_relation_g` created in previous chunk as example, we will get actor node (`name`), `age` (attribute 1) and `gender` (attribute 2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nV(actor_relation_g)$name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Alice\"     \"Bob\"       \"Cecil\"     \"David\"     \"Esmeralda\"\n```\n:::\n\n```{.r .cell-code}\nV(actor_relation_g)$age\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 48 33 45 34 21\n```\n:::\n\n```{.r .cell-code}\nV(actor_relation_g)$gender\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"F\" \"M\" \"F\" \"M\" \"F\"\n```\n:::\n:::\n\n\nWe can also get all the vertex attributes to a data.frame using `igraph::as_data_frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::as_data_frame(actor_relation_g, what = \"vertices\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               name age gender\nAlice         Alice  48      F\nBob             Bob  33      M\nCecil         Cecil  45      F\nDavid         David  34      M\nEsmeralda Esmeralda  21      F\n```\n:::\n:::\n\n\nSimilarly, to get edge list and their attributes from graph object, we use `E(graph)$\"<attribute_name>\"` to convert graph object to vector. OR using `igraph::as_data_frame()` to convert all edges to a data.frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# edge attributes\nE(actor_relation_g)$same.dept\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nE(actor_relation_g)$friendship\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5 5 2 1 1\n```\n:::\n\n```{.r .cell-code}\n# edge data.frame\nigraph::as_data_frame(actor_relation_g, what = \"edges\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       from    to same.dept friendship advice\n1       Bob Alice     FALSE          4      4\n2     Cecil   Bob     FALSE          5      5\n3     Cecil Alice      TRUE          5      5\n4     David Alice     FALSE          2      4\n5     David   Bob     FALSE          1      2\n6 Esmeralda Alice      TRUE          1      3\n```\n:::\n:::\n\n\n## Add vertex and edges\n\nVertices and edges can be added to existing graph by `add_<vertices|edges>()` or `+ <vertices|edges>()`. Please be aware that vertices of added new edges must be from known vertices already in the graph.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add vertices \nactor_relation_g %>% \n    add_vertices(2, name=c(\"Lisa\",\"Zack\")) # the first argument is number of vertex\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 80dfeea DN-- 7 6 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 80dfeea (vertex names):\n[1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice\n[5] David    ->Bob   Esmeralda->Alice\n```\n:::\n\n```{.r .cell-code}\nactor_relation_g + vertices(c(\"Lisa\",\"Zack\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH de6630f DN-- 7 6 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from de6630f (vertex names):\n[1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice\n[5] David    ->Bob   Esmeralda->Alice\n```\n:::\n:::\n\n\nTo add new edge, the new edge must be between known vertices already in the graph.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add connected edges (even number of vertices). \nactor_relation_g %>% \n    add_edges(c(\"Alice\",\"Bob\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH d7c4121 DN-- 5 7 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from d7c4121 (vertex names):\n[1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice\n[5] David    ->Bob   Esmeralda->Alice Alice    ->Bob  \n```\n:::\n\n```{.r .cell-code}\nactor_relation_g + edge(c(\"Alice\",\"Bob\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH ad4c43b DN-- 5 7 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from ad4c43b (vertex names):\n[1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice\n[5] David    ->Bob   Esmeralda->Alice Alice    ->Bob  \n```\n:::\n:::\n\n\nThe edges can be also be added by `+ path()`. The path is a `igraph.path` object that each element is connected to the next, but it is not a `IGRAPH` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add paths. The vertices must be from known vertices already in the graph \nactor_relation_g + path(\"Alice\",\"Bob\",\"Cecil\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 48d4748 DN-- 5 8 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 48d4748 (vertex names):\n[1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice\n[5] David    ->Bob   Esmeralda->Alice Alice    ->Bob   Bob      ->Cecil\n```\n:::\n:::\n\n\nIf a new vertex needs to be added to current graph, using add graph method instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nactor_relation_g + make_graph(c(\"Alice\",\"Bob\",\"Bob\",\"Melisa\")) # this create same path as above\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH def4db0 DN-- 6 8 -- \n+ attr: age (v/n), gender (v/c), name (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from def4db0 (vertex names):\n[1] Esmeralda->Alice  David    ->Bob    David    ->Alice  Cecil    ->Bob   \n[5] Cecil    ->Alice  Bob      ->Melisa Bob      ->Alice  Alice    ->Bob   \n```\n:::\n:::\n\n\n## Delete vertex and edges\n\nDelete can be done by `delete_<vertices|edges>()` using either index or name of vertices\\|edges.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### remove the vertices whose age is younger than 30\nvertex_df = actor_relation_g %>% \n    igraph::as_data_frame(what=\"vertices\") %>% \n        dplyr::as_tibble() %>% \n        dplyr::mutate(index=row_number()) %>% \n        dplyr::filter(age < 30)\n\n# remove vertices by index number \nactor_relation_g %>% delete_vertices(vertex_df$index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 82b2916 DN-- 4 5 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 82b2916 (vertex names):\n[1] Bob  ->Alice Cecil->Bob   Cecil->Alice David->Alice David->Bob  \n```\n:::\n\n```{.r .cell-code}\n# remove vertice by name \nactor_relation_g %>% delete_vertices(vertex_df$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 464f2cc DN-- 4 5 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 464f2cc (vertex names):\n[1] Bob  ->Alice Cecil->Bob   Cecil->Alice David->Alice David->Bob  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### remove the edges with friendship <= 1 \nedge_df = actor_relation_g %>% \n    igraph::as_data_frame(what=\"edges\") %>% \n    dplyr::as_tibble() %>% \n    mutate(index=row_number()) %>% \n    mutate(name=paste(from,to,sep=\"|\")) %>% \n    filter(friendship <= 1)\n\n# remove vertice by index\nactor_relation_g %>% delete_edges(edge_df$index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 8643b08 DN-- 5 4 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 8643b08 (vertex names):\n[1] Bob  ->Alice Cecil->Bob   Cecil->Alice David->Alice\n```\n:::\n\n```{.r .cell-code}\n# remove vertice by name \nactor_relation_g %>% delete_edges(edge_df$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 05c4850 DN-- 5 4 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 05c4850 (vertex names):\n[1] Bob  ->Alice Cecil->Bob   Cecil->Alice David->Alice\n```\n:::\n:::\n\n\n## Set/Delete the attributes of vertex and edges\n\nThe attributes of vertices and edges can be added or deleted to existing graph by `set_vertex_attr()`/`set_edge_attr()` or `delete_vertex_attr()`/`delete_edge_attr()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add a new attr \"relationship\" for people in the same dept\nedge_df <-\n    actor_relation_g %>% igraph::as_data_frame(what = \"edges\") %>%\n    mutate(relationship = ifelse(same.dept, \"collegue\", NA))\n\nactor_relation_g %>%\n    set_edge_attr(\"relationship\", which(!is.na(edge_df$relationship)), edge_df$relationship[!is.na(edge_df$relationship)]\n                  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 05d16d7 DN-- 5 6 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n), relationship (e/c)\n+ edges from 05d16d7 (vertex names):\n[1] Bob      ->Alice Cecil    ->Bob   Cecil    ->Alice David    ->Alice\n[5] David    ->Bob   Esmeralda->Alice\n```\n:::\n:::\n\n\n## Merge graph\n\nGraphs union/intersection is to merge two or more graphs into one graph using the shared the vertices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create new graph\ng2 <- graph_from_literal(\"David\"-+\"Charlie\"+-+\"Lisa\",\n                        \"Lisa\"+-+\"David\"+-\"Jim\",\n                        \"Zack\"+-\"Esmeralda\"-+\"Bob\",\n                        \"Zack\"+-\"Charlie\",\n                        \"Lisa\"+-\"Lisa\",\n                        \"Bob\"-+\"Alice\"+-\"Esmeralda\"\n                        )\n\n#### union graph\ng3 <- igraph::union(actor_relation_g,g2)\n\n#### graph intersection\ng4 <- igraph::intersection(actor_relation_g,g2)\n\n### plot new graphs\npar(mfrow=c(2,2)) \nplot(actor_relation_g, edge.arrow.size=.4)\nplot(g2, edge.arrow.size=.4)\nplot(g3, edge.arrow.size=.4)\nplot(g4, edge.arrow.size=.4)\n```\n\n::: {.cell-output-display}\n![](2019-07-11_network_analysis_part1_files/figure-html/merge-1.png){width=672}\n:::\n:::\n\n\n## Induce subgraph\n\nThe subgraph can be induced by either vertex or edge names/index. The edge names are in the form `from|to`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# induce a subgraph using a list of vertices\nigraph::induced_subgraph(actor_relation_g, v=c(\"Alice\",\"Bob\",\"Cecil\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 4f5b3fb DN-- 3 3 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 4f5b3fb (vertex names):\n[1] Bob  ->Alice Cecil->Bob   Cecil->Alice\n```\n:::\n\n```{.r .cell-code}\n# induce a subgraph using edges\nigraph::subgraph.edges(actor_relation_g, c(\"Bob|Alice\",\"David|Bob\",\"Cecil|Alice\"), delete.vertices = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH a710864 DN-- 4 3 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from a710864 (vertex names):\n[1] Bob  ->Alice Cecil->Alice David->Bob  \n```\n:::\n\n```{.r .cell-code}\n# induce a subgraph using edges attribute (friendship score stronger than 3)\ne1 = E(actor_relation_g)[E(actor_relation_g)$friendship > 3]\nigraph::subgraph.edges(actor_relation_g, e1, delete.vertices = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 7e403b5 DN-- 3 3 -- \n+ attr: name (v/c), age (v/n), gender (v/c), same.dept (e/l),\n| friendship (e/n), advice (e/n)\n+ edges from 7e403b5 (vertex names):\n[1] Bob  ->Alice Cecil->Bob   Cecil->Alice\n```\n:::\n:::\n\n\n# Relationship between known nodes\n\nWith a known graph, we sometimes want to know relationship between two known nodes. eg. are those two nodes adjacent? are those two nodes linked by a path? what are the path to connect them?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# check two nodes adjacent. return boolean\nare_adjacent(g3,\"Jim\", \"Zack\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# paths to connect \nall_shortest_paths(g3, \"Jim\",\"Zack\")$res[[1]] # return a igraph.vs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 4/9 vertices, named, from 3eded49:\n[1] Jim     David   Charlie Zack   \n```\n:::\n\n```{.r .cell-code}\nall_simple_paths(g3, \"Jim\", \"Zack\") # return a list of igraph.vs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 4/9 vertices, named, from 3eded49:\n[1] Jim     David   Charlie Zack   \n\n[[2]]\n+ 5/9 vertices, named, from 3eded49:\n[1] Jim     David   Lisa    Charlie Zack   \n```\n:::\n\n```{.r .cell-code}\nall_simple_paths(g3, \"Jim\", \"Zack\", mode = \"all\")  # regardless of direction\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 6/9 vertices, named, from 3eded49:\n[1] Jim       David     Alice     Bob       Esmeralda Zack     \n\n[[2]]\n+ 7/9 vertices, named, from 3eded49:\n[1] Jim       David     Alice     Cecil     Bob       Esmeralda Zack     \n\n[[3]]\n+ 5/9 vertices, named, from 3eded49:\n[1] Jim       David     Alice     Esmeralda Zack     \n\n[[4]]\n+ 6/9 vertices, named, from 3eded49:\n[1] Jim       David     Bob       Alice     Esmeralda Zack     \n\n[[5]]\n+ 7/9 vertices, named, from 3eded49:\n[1] Jim       David     Bob       Cecil     Alice     Esmeralda Zack     \n\n[[6]]\n+ 5/9 vertices, named, from 3eded49:\n[1] Jim       David     Bob       Esmeralda Zack     \n\n[[7]]\n+ 4/9 vertices, named, from 3eded49:\n[1] Jim     David   Charlie Zack   \n\n[[8]]\n+ 5/9 vertices, named, from 3eded49:\n[1] Jim     David   Lisa    Charlie Zack   \n```\n:::\n:::\n\n\nIn next post, I will discuss how to use `{igraph}` package to measure and cluster network and use the `IGRAPH` object to its fullest potential.\n",
    "supporting": [
      "2019-07-11_network_analysis_part1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}